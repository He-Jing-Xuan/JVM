### 2.2 java 运行时数据区域

- javaj虚拟机在执行Java程序时，将他所管理的**内存划分为若干个不同的 数据区域**。各区域 有不同的用途以及创建和销毁的时间也不同。
  - **方法区**
  - **堆**
  - **虚拟机栈**
  - **本地方法栈**
  - **程序计数器**
  - **程序计数器**

#### 2.2.1 什么是程序计数器？

- 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的**字节码的行号指示器**

- 字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指令，他是程序控制类的指示器。

- 分支循环，跳转，异常处理，线程恢复等基础功能都需要计数器来完成。

由于Java多线程的实现是通过线程轮流切换，分配处理器执行时间的方式来实现的，在任意一个时刻一个处理器只能处理一条线程的指令。因此，**为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器**。 各线程之间互补影响，这样的内存区域是线程私有的。

- **如果执行的是本地方法则程序计数器为空，若是Java方法则计数器记录的是正在执行的虚拟机字节码指令的地址。**

  

#### 2.2.2 Java虚拟机栈

- **Java虚拟机栈也是私有的，生命周期和线程相同。**
- **Java虚拟机栈描述的是Java方法执行的线程内存模型**
  - 每个方法被执行的时候，Java虚拟机就会创建一个栈帧用于存储局部变量表，操作数栈，动态连接，方法出口等信息。

- 局部变量表存放 **基本数据类型，对象引用，returnAddress类型**（执行一个字节码指令的地址）
  - 这些数据类型，在局部变量表中的存储空间用 **“局部变量槽”**表示。
- **内存区域规定两种异常：**
  - **stackOverflowError：线程请求的栈深度大于虚拟机所允许的深度栈溢出**
  - **OutofMemoryError：当栈申请扩展内存时，无法申请到足够的内存抛出的异常**



### 2.2.3 本地方法栈

- 本地方法栈是为了虚拟机使用到本地方法服务。 HotSpot将本地方法栈和虚拟机方法栈合二为一。

### 2.2.4 Java堆

- **Java堆是虚拟机所管理的内存中最大的一种。**
- **Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。**
- **java堆唯一目的就是存放对象实例。几乎所有的对象实例都是在堆中分配内存。**
- Java堆是垃圾收集器管理的内存区域。
- **从分配内存的角度看，所有线程共享的Java堆中可以划分出 多个 线程私有的 分配缓冲区，以提升对象分配时的效率。**
- Java堆可以不是物理上的连续的内存空间，但逻辑上应该是一样的。
- Java堆现在主流的是 可扩展来实现的。

### 2.2.5 方法区

- 方法区也是各线程共有的内存区域。
- **用于存储被虚拟机已加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存等数据。**
- 方法区除了 不需要连续的内存和可以选择固定大小或者可扩展外，还可以**选择不实现垃圾收集。**
- 方法区内存回收目标主要是针对常量池的回收和对类型的卸载。但回收效果一般，尤其是类型的卸载。

### 2.2.6 运行时常量池

- 运行时常量池是方法区的一部分。Class文件除了有类的版本，字段，方法，接口外，还有一个**常量池表-->用于存放编译期生成的各中字面量和符号引用。** ---》这部分内容在类加载后存放到方法区的运行时常量池中。
- 运行时常量池**除了保存Class文件中的描述的符号引用外，还会把符号引用翻译出来的直接引用也保存。**

- 运行时常量池相**对于Class文件的常量池 具备动态性**。Java语言并非要求一定只有编译期产生常量。在代码运行期间，可以**生成新的常量置于运行时方法区中**。

### java堆内存

- 堆
- 



